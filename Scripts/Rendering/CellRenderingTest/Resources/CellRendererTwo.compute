#pragma kernel CellRenderer

// Output texture
RWTexture2D<float4> Result;
RWStructuredBuffer<int3> rayCellBuffer;
RWStructuredBuffer<float3> testOffsetBuffer;
int rayCellAmount;

cbuffer CameraBuffer
{
    float4x4 viewMatrix;
    float4x4 projectionMatrix;
    float4x4 inverseViewMatrix;     // Added inverse view matrix for transforming rays
    float4x4 inverseProjectionMatrix; // Pass the inverse projection matrix from C# code
    float3 cameraPosition;          // Camera world position
    uint2 resolution;
}
float3 ViewParams;

float3 boundsMin;
float3 boundsMax;
float gridSize;
// Struct for ray data
struct RayData
{
    float3 origin;
    float3 direction;
};

struct CellIntersectionData
{
    int3 firstCell;
    int3 lastCell;
    int cellCount;
};

float4 backgroundColor;
float4 cellBaseColor;
float4 sphereColor;
float sphereRadius;
float3 sunDirection;

float3 rayCellOrigin;
float3 rayCellDirection;
int rayCellIndex;
int showAllCells;

float3 testCell;
int testCellIndex;

int onlyShowGrid;
float gridWireFrameSize;

float3 WorldToGrid(float3 worldPos)
{
    float3 relativePos = worldPos - boundsMin;
    float3 gridPos = relativePos / gridSize;
    return gridPos;
}

float3 GridToWorld(float3 gridPos)
{
    float3 relativePos = gridPos * gridSize;
    float3 worldPos = relativePos + boundsMin;
    return worldPos;
}
float3 RayCellIntersection(RayData rayData, float3 cubeMin, float3 cubeMax, bool getFront)
{
    
    float3 rayDir = rayData.direction;
    float3 rayOrigin = rayData.origin;

    // Initialize tMin and tMax for the intersection test
    float tMin = 0.0f;
    float tMax = 1e10f;
    float3 planeNormal = float3(0.0f, 0.0f, 0.0f);

    // Iterate over each axis (X, Y, Z)
    for (int i = 0; i < 3; i++)
    {
        if (abs(rayDir[i]) < 1e-6f) // Ray is parallel to slab
        {
            // If the origin is not within the slab, no intersection
            if (rayOrigin[i] < cubeMin[i] || rayOrigin[i] > cubeMax[i])
            {
                return float3(0.0f, 0.0f, 0.0f);
            }
        }
        else
        {
            // Compute intersection distances with the slabs
            float t1 = (cubeMin[i] - rayOrigin[i]) / rayDir[i];
            float t2 = (cubeMax[i] - rayOrigin[i]) / rayDir[i];

            // Swap t1 and t2 if necessary
            if (t1 > t2)
            {
                float temp = t1;
                t1 = t2;
                t2 = temp;
            }

            // Update tMin and tMax
            if (t1 > tMin)
            {
                tMin = t1;
                planeNormal = float3(0.0f, 0.0f, 0.0f);
                planeNormal[i] = (rayDir[i] < 0) ? 1.0f : -1.0f;
            }
            tMax = min(tMax, t2);

            // If tMax < tMin, no intersection
            if (tMax < tMin)
            {
                return float3(0.0f, 0.0f, 0.0f);
            }
        }
    }

    float tHit = tMin;
    if(!getFront)
        tHit = tMax;

    if (tHit < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // Intersection is behind the ray origin
    }

    // Calculate the hit point using the ray equation: hitPoint = rayOrigin + tHit * rayDir
    float3 hitPoint = rayOrigin + tHit * rayDir;
    return hitPoint;
}

float3 RayLineSegmentIntersection(RayData rayData, float3 lineStart, float3 lineEnd, float lineRadius)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDir = rayData.direction;
    // Calculate the direction of the line segment
    float3 lineDir = normalize(lineEnd - lineStart);
    float lineLength = length(lineEnd - lineStart);

    // Transform the ray to the line's local coordinate system
    float3 lineToRay = rayOrigin - lineStart;
    float3 w = lineToRay - dot(lineToRay, lineDir) * lineDir;
    float3 u = rayDir - dot(rayDir, lineDir) * lineDir;

    float a = dot(u, u);
    float b = 2.0f * dot(u, w);
    float c = dot(w, w) - lineRadius * lineRadius;

    // Solve the quadratic equation: at^2 + bt + c = 0
    float discriminant = b * b - 4.0f * a * c;
    if (discriminant < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // No intersection
    }

    float sqrtDiscriminant = sqrt(discriminant);
    float t1 = (-b - sqrtDiscriminant) / (2.0f * a);
    float t2 = (-b + sqrtDiscriminant) / (2.0f * a);

    // Find the closest positive t value
    float tHit = (t1 >= 0.0f) ? t1 : ((t2 >= 0.0f) ? t2 : -1.0f);
    if (tHit < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // No valid intersection
    }

    // Calculate the hit point using the ray equation: hitPoint = rayOrigin + tHit * rayDir
    float3 hitPoint = rayOrigin + tHit * rayDir;

    // Ensure the hit point is within the bounds of the line segment
    float projectionLength = dot(hitPoint - lineStart, lineDir);
    if (projectionLength < 0.0f || projectionLength > lineLength)
    {
        return float3(0.0f, 0.0f, 0.0f); // Hit point is outside valid range
    }

    return hitPoint;
}
int3 GetCellFromIndex(int cellIndex)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    int cellZ = cellIndex / (cellCount.x * cellCount.y);

    int remainingIndex = cellIndex - cellZ * cellCount.x * cellCount.y;

    int cellY = remainingIndex / cellCount.x;

    int cellX = remainingIndex - cellY * cellCount.x;

    int3 cell = int3(cellX, cellY, cellZ);

    /*if(cell.x < 0 || cell.y < 0 || cell.z < 0)
        return cellCount + int3(1, 0, 0);
    if(cell.x > cellCount.x || cell.y > cellCount.y || cell.z > cellCount.z)
        return cellCount + int3(1, 0, 0);*/
    return cell - cellCount / 2;
}

float3 PositionFromCell(int3 cell)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    int3 cellLocal = cell + cellCount / 2;

    float3 cellPos = boundsMin + float3(cellLocal) * gridSize;

    return cellPos;
}
float3 RayCellIntersection(RayData rayData, int cellIndex)
{
    int3 cell = GetCellFromIndex(cellIndex);
    /*if(cell.x == ceil((boundsMax - boundsMin) / gridSize).x)
        return float3(0, 0, 0);*/
    float3 cellPos = PositionFromCell(cell);
    float3 cubeMin = cellPos;
    float3 cubeMax = cellPos + gridSize;
    return RayCellIntersection(rayData, cubeMin, cubeMax, true);
}

float3 RaySphereIntersection(RayData rayData, float3 center, float radius)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDirection = rayData.direction;
    radius = radius * length(rayData.origin);

    float3 oc = rayOrigin - center;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc, oc) - radius * radius;

    float discriminant = b * b - 4 * a * c;
    float3 hitPoint = float3(0, 0, 0);

    if (discriminant > 0)
    {
        // Calculate the nearest hit point using the smaller root
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0)
        {
            hitPoint = rayOrigin + t * rayDirection;
        }
    }
    return hitPoint; // No intersection
}
bool RayIntersectsSphere(RayData rayData)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDirection = rayData.direction;

    float3 oc = rayOrigin;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc, oc) - 1;

    float discriminant = b * b - 4 * a * c;

    if (discriminant > 0)
    {
        // Calculate the nearest hit point using the smaller root
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0)
        {
            return true; // Intersection found
        }
    }

    return false; // No intersection
}
float4 RaySphereIntersectionColor(RayData rayData)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDirection = rayData.direction;

    float3 oc = rayOrigin;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;

    float discriminant = b * b - 4 * a * c;

    float3 hitPoint = float3(0, 0, 0);
    float3 hitPoint1 = float3(0, 0, 0);
    float3 hitPoint2 = float3(0, 0, 0);

    float transparency = 1.0;
    float transparency1 = 0.5;
    float transparency2 = 0.5;
    if (discriminant > 0)
    {
        // Calculate the nearest hit point using the smaller root
        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);
        
        
        if (t1 > 0)
        {
            hitPoint1 = rayOrigin + t1 * rayDirection;
            hitPoint = hitPoint1;
            transparency1 = 0.5 + (dot(normalize(hitPoint1), rayDirection) * 0.5);
        }
        if (t2 > 0)
        {
            hitPoint2 = rayOrigin + t2 * rayDirection;
            transparency2 = 0.5 - (dot(normalize(hitPoint2), rayDirection) * 0.5);
        }
    }
    if(length(hitPoint) == 0)
        return float4(0, 0, 0, 0);
    transparency = transparency1 + transparency2;
    float4 returnColor = float4(sphereColor.xyz * transparency, transparency);
    return returnColor;
}

float3 RayPlaneIntersection(RayData rayData, float3 planePoint, float3 planeNormal)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDirection = rayData.direction;

    float3 offset = planePoint - rayOrigin;

    float denom = dot(planeNormal, rayDirection);

    if(denom == 0)
        return float3(0, 0, 0);
    /*if(denom < 0)
        return rayOrigin;*/
    float t = dot(offset, planeNormal) / denom;
    if(t < 0)
        return float3(0, 0, 0);

    return rayOrigin + t * rayDirection;
    
}
// Converts a pixel to ray data
RayData PixelToRay(uint2 pixel)
{
    float2 uv = float2(pixel) / float2(resolution);
    float3 pixelPointLocal = float3((uv - 0.5), 1);
    //float4 clipSpacePos = float4(uv * 2.0 - 1.0, -1.0, 1.0);
    float3 pixelPoint = mul(inverseProjectionMatrix, float4(pixelPointLocal, 1));
	float3 rayOrigin = cameraPosition;

    float3 rayDirLocal = normalize(pixelPoint);
	float3 rayDir = normalize(mul((float3x3)inverseViewMatrix, rayDirLocal));
    RayData rayData;
    rayData.origin = rayOrigin;
    rayData.direction = rayDir;

    return rayData;
}
// Converts a pixel to ray data
/*RayData PixelToRay2(uint2 pixel)
{
    float2 uv = pixel / resolution;
    float3 pixelPointLocal = float3(pixel - 0.5, 1) * ViewParams;
    float3 pixelPoint = mul(inverseProjectionMatrix, float4(pixelPointLocal, 1));
    float3 rayOrigin = cameraPosition;
    float3 rayDirViewSpace = normalize(pixelPoint - rayOrigin);
    float3 rayDir = normalize(mul((float3x3)inverseViewMatrix, rayDirViewSpace));
    RayData rayData;
    rayData.origin = rayOrigin;
    rayData.direction = rayDir;

    return rayData;
}*/
/*RayData PixelToRay(uint2 pixel)
{
    float2 uv = pixel / resolution;
    float4 clipSpacePos = float4(uv * 2.0 - 1.0, -1.0, 1.0); // Clip space coordinates, z = -1 for near plane

    // Transform from clip space to view space
    float4 viewSpacePos = mul(inverseProjectionMatrix, clipSpacePos);
    viewSpacePos /= viewSpacePos.w; // Perspective divide to get view space coordinates

    // The ray direction in view space (from the camera towards the pixel)
    float3 rayDirectionViewSpace = normalize(viewSpacePos.xyz);

    // Transform the ray direction to world space
    float3 rayDirectionWorldSpace = normalize(mul((float3x3)inverseViewMatrix, rayDirectionViewSpace));

    RayData rayData;
    rayData.origin = cameraPosition;
    rayData.direction = rayDirectionWorldSpace;

    return rayData;
}*/


float3 GetClosestHitPoint(RayData rayData, float3 hxMin, float3 hyMin, float3 hzMin, float3 hxMax, float3 hyMax, float3 hzMax)
{
    float dxMin = distance(rayData.origin, hxMin);
    float dyMin = distance(rayData.origin, hyMin);
    float dzMin = distance(rayData.origin, hzMin);
    float dxMax = distance(rayData.origin, hxMax);
    float dyMax = distance(rayData.origin, hyMax);
    float dzMax = distance(rayData.origin, hzMax);

    float minDist = dxMin;
    if(dyMin < minDist)
        minDist = dyMin;
    if(dzMin < minDist)
        minDist = dzMin;
    if(dxMax < minDist)
        minDist = dxMax;
    if(dyMax < minDist)
        minDist = dyMax;
    if(dzMax < minDist)
        minDist = dzMax;
    
    return rayData.origin + rayData.direction * minDist;
}

float3 GetFarthestHitPoint(RayData rayData, float3 hxMin, float3 hyMin, float3 hzMin, float3 hxMax, float3 hyMax, float3 hzMax)
{
    float dxMin = distance(rayData.origin, hxMin);
    float dyMin = distance(rayData.origin, hyMin);
    float dzMin = distance(rayData.origin, hzMin);
    float dxMax = distance(rayData.origin, hxMax);
    float dyMax = distance(rayData.origin, hyMax);
    float dzMax = distance(rayData.origin, hzMax);

    float maxDist = dxMin;
    if(dyMin > maxDist)
        maxDist = dyMin;
    if(dzMin > maxDist)
        maxDist = dzMin;
    if(dxMax > maxDist)
        maxDist = dxMax;
    if(dyMax > maxDist)
        maxDist = dyMax;
    if(dzMax > maxDist)
        maxDist = dzMax;
    
    return rayData.origin + rayData.direction * maxDist;
}

int3 CellFromPoint(float3 hitPoint)
{
    //float3 localPos = hitPoint - boundsMin;
    //int3 localCell = floor(localPos / gridSize);


    int3 cell = floor(hitPoint / gridSize);
    return cell;
}

int GetCellIndex(int3 cell)
{
    int3 cellCount = ceil(((boundsMax - boundsMin) / gridSize));

    int cellIndex = cell.x + cell.y * cellCount.x + cell.z * (cellCount.x * cellCount.y);
    return cellIndex;
}



CellIntersectionData GetCellIntersections(RayData rayData, inout RayData boundsRay)
{
    RayData tempBoundsRayData;
    tempBoundsRayData.origin = WorldToGrid(rayData.origin);
    tempBoundsRayData.direction = rayData.direction;
    float3 firstHit = RayCellIntersection(tempBoundsRayData, WorldToGrid(boundsMin), WorldToGrid(boundsMax), true) + 0.01;
    float3 lastHit = RayCellIntersection(tempBoundsRayData, WorldToGrid(boundsMin), WorldToGrid(boundsMax), false) + 0.01;

    //firstHit = WorldToGrid(firstHit);
    //lastHit = WorldToGrid(lastHit);

    boundsRay.origin = firstHit;
    boundsRay.direction = rayData.direction * distance(firstHit, lastHit);

    int3 firstCell = floor(firstHit);
    int3 lastCell = floor(lastHit);
    int3 difference = abs(firstCell - lastCell);
    int cellCount = 1 + difference.x + difference.y + difference.z;

    

    CellIntersectionData cellIntersectionData;
    cellIntersectionData.firstCell = firstCell;
    cellIntersectionData.lastCell = lastCell;
    cellIntersectionData.cellCount = cellCount;
    return cellIntersectionData;
}
float3 SortFloat3(float3 v)
{
    float a = v.x;
    float b = v.y;
    float c = v.z;

    // Compare and swap to sort the values
    if (a > b) { float temp = a; a = b; b = temp; }
    if (a > c) { float temp = a; a = c; c = temp; }
    if (b > c) { float temp = b; b = c; c = temp; }

    // Return the sorted float3
    return float3(a, b, c);
}
int3 GetCellFromIntersectionIndex(RayData boundsRay, int intersectionIndex)
{
    float3 positiveCoordinateMatrix = float3(sign(boundsRay.direction.x), sign(boundsRay.direction.y), sign(boundsRay.direction.z));

    float3 relativeDirection = boundsRay.direction * positiveCoordinateMatrix;
    float3 relativeOrigin = ((boundsRay.origin * positiveCoordinateMatrix - floor(boundsRay.origin * positiveCoordinateMatrix)) + float3(1,1,1) * 0.01);

    float t = ((float)intersectionIndex + 1.0 - (relativeOrigin.x + relativeOrigin.y + relativeOrigin.z)) / (relativeDirection.x + relativeDirection.y + relativeDirection.z);
    float3 relativeHitPoint = relativeOrigin + t * relativeDirection;
    int3 relativeCell = floor(relativeHitPoint);
    int sum = relativeCell.x + relativeCell.y + relativeCell.z;
    if(sum == intersectionIndex)
        return floor(boundsRay.origin) + relativeCell * positiveCoordinateMatrix;
    float3 distanceToNext = ceil(relativeHitPoint) - relativeHitPoint;
    float3 tToNext = distanceToNext / relativeDirection;
    float tMin = min(min(tToNext.x, tToNext.y), tToNext.z);
    float3 nextHitPoint = relativeOrigin + (t + tMin) * relativeDirection;
    int3 nextRelativeCell = floor(nextHitPoint + 0.01);
    return floor(boundsRay.origin) + nextRelativeCell * positiveCoordinateMatrix;
}
int3 GetCellFromIntersectionIndexTest(RayData boundsRay, int intersectionIndex)
{
    /*RayData rayData;
    rayData.origin = boundsRay.origin;
    rayData.direction = normalize(boundsRay.direction);

    
    float3 rayOrigin = boundsRay.origin;
    float3 rayOriginOffset = rayOrigin - floor(rayOrigin + normalize(rayData.direction) * 0.001);
    float3 rayDir = normalize(boundsRay.direction);

    float3 indexPoint = rayOriginOffset + float3(0.5, 0.5, 0.5) * (float)intersectionIndex;

    float3 planeHitPoint = RayPlaneIntersection(rayData, indexPoint, boundsRay.direction);
    return int3(floor(planeHitPoint));*/
    float3 rayOrigin = boundsRay.origin;

    float3 rayOriginOffset = (rayOrigin - floor(rayOrigin));
    float3 rayDir = normalize(boundsRay.direction);
    float3 coordinateFlipper = float3(sign(rayDir.x), sign(rayDir.y), sign(rayDir.z));
    
    float3 rayDirFlipped = rayDir * coordinateFlipper;
    float3 offsetFlipped = rayOriginOffset * coordinateFlipper;

    float3 h = rayOriginOffset / rayDir;

    float t1 = (((float)intersectionIndex + 1) - (offsetFlipped.x + offsetFlipped.y + offsetFlipped.z)) / (rayDirFlipped.x + rayDirFlipped.y + rayDirFlipped.z);
    float3 intersectionHitPoint = rayOrigin + rayDir * t1;

    float3 intersectionHitPointFlipped = offsetFlipped + rayDirFlipped * t1;
    int3 estimatedCell = floor(intersectionHitPointFlipped);
    int total = estimatedCell.x + estimatedCell.y + estimatedCell.z;
    if(total == intersectionIndex)
        return floor(intersectionHitPoint);


    float3 distanceToNext = ceil(intersectionHitPointFlipped) - intersectionHitPointFlipped;
    float3 t2 = SortFloat3(distanceToNext / rayDirFlipped);

    float t2Min = t2[(int)(abs(total - intersectionHitPoint) - 1)];
    float3 nextIntersectionHitPoint = rayOrigin + rayDir * (t1 + t2Min);
    int3 nextCell = floor(nextIntersectionHitPoint);
    return nextCell;
    //float3 deltaT = (ceil(abs(estimatedPoint)) - abs(estimatedPoint)) / abs(rayDir);
    //float increment = 0;
    //float3 deltaTNormalized = normalize(deltaT);
    //int3 mask = int(floor(deltaTNormalized / max(max(deltaTNormalized.x, deltaTNormalized.y), deltaTNormalized.z) + 0.01));
    int3 cell = floor(intersectionHitPoint);
    return cell;
}
int3 GetCellFromIntersectionIndex2(RayData boundsRay, int intersectionIndex)
{
    float3 rayOrigin = boundsRay.origin;

    float3 rayOriginOffset = rayOrigin - floor(rayOrigin + 0.001);
    float3 rayDir = normalize(boundsRay.direction);

    float3 h = rayOriginOffset / rayDir;

    float tt = ((float)intersectionIndex - (rayOriginOffset.x + rayOriginOffset.y + rayOriginOffset.z)) / (abs(rayDir.x) + abs(rayDir.y) + abs(rayDir.z));
    float3 intersectionHitPoint = rayOrigin + rayDir * tt;

    //float3 deltaT = (ceil(abs(estimatedPoint)) - abs(estimatedPoint)) / abs(rayDir);
    //float increment = 0;
    //float3 deltaTNormalized = normalize(deltaT);
    //int3 mask = int(floor(deltaTNormalized / max(max(deltaTNormalized.x, deltaTNormalized.y), deltaTNormalized.z) + 0.01));
    int3 cell = floor(intersectionHitPoint);
    return cell;
}

// Finds the closest intersecting object
int3 FindCell(RayData rayData, inout RayData boundsRay)
{
    int closestObjectIndex = -1;
    float minDist = 1e6;

    CellIntersectionData cellIntersectionData = GetCellIntersections(rayData, boundsRay);

    int3 cell = GetCellFromIntersectionIndex(boundsRay, rayCellIndex);

    return cell;
}

// Finds the closest intersecting object
int3 FindClosestCell(RayData cellRayData, RayData rayData, inout int2 rayCellData)
{
    int3 closestCell = -1;
    int minIndex = -1;
    float minDist = 1e6;
    RayData boundsRay;
    CellIntersectionData cellIntersectionData = GetCellIntersections(cellRayData, boundsRay);
    
    for(int i = 0; i < cellIntersectionData.cellCount; i++)
    {
        int3 cell = GetCellFromIntersectionIndex(boundsRay, i);
        if(i < rayCellAmount)
            rayCellBuffer[i] = cell;
        int cellIndex = GetCellIndex(cell);

        float3 hitPoint = RayCellIntersection(rayData, cellIndex);
        if(length(hitPoint) != 0)
        {
            float dist = distance(rayData.origin, hitPoint);
            if(dist < minDist)
            {
                closestCell = cell;
                minIndex = i;
                minDist = distance(rayData.origin, hitPoint);
            }
            
        }
    }
    rayCellData = int2(minIndex, cellIntersectionData.cellCount);

    return closestCell;
}
/*float3 hxMin = RayPlaneIntersection(rayData, float3(boundsMin.x, 0, 0), float3(-1.0, 0, 0));
float3 hyMin = RayPlaneIntersection(rayData, float3(0, boundsMin.y, 0), float3(0, -1.0, 0));
float3 hzMin = RayPlaneIntersection(rayData, float3(0, 0, boundsMin.z), float3(0, 0, -1.0));

float3 hxMax = RayPlaneIntersection(rayData, float3(boundsMax.x, 0, 0), float3(1.0, 0, 0));
float3 hyMax = RayPlaneIntersection(rayData, float3(0, boundsMax.y, 0), float3(0, 1.0, 0));
float3 hzMax = RayPlaneIntersection(rayData, float3(0, 0, boundsMax.z), float3(0, 0, 1.0));*/
// Get the color of the object or background
float4 GetObjectColor(int objectIndex)
{
    return backgroundColor;
}






float3 RayAxisIntersectionFar(RayData rayData, float3 axis, float radius)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDir = rayData.direction;
    // Ensure the axis is normalized
    float3 normalizedAxis = normalize(axis);

    radius = radius * length(rayData.origin);

    // Project ray origin onto the plane perpendicular to the axis
    float3 w = rayOrigin - dot(rayOrigin, normalizedAxis) * normalizedAxis;
    float3 u = rayDir - dot(rayDir, normalizedAxis) * normalizedAxis;

    float a = dot(u, u);
    float b = 2.0f * dot(u, w);
    float c = dot(w, w) - radius * radius;

    // Solve the quadratic equation: at^2 + bt + c = 0
    float discriminant = b * b - 4.0f * a * c;
    if (discriminant < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // No intersection
    }

    float sqrtDiscriminant = sqrt(discriminant);
    float t1 = (-b - sqrtDiscriminant) / (2.0f * a);
    float t2 = (-b + sqrtDiscriminant) / (2.0f * a);

    // Find the closest positive t value
    float tHit = (t2 >= 0.0f) ? t2 : ((t1 >= 0.0f) ? t1 : -1.0f);
    if (tHit < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // No valid intersection
    }
    // Calculate the hit point using the ray equation: hitPoint = rayOrigin + tHit * rayDir
    float3 hitPoint = rayOrigin + t2 * rayDir;
    // Ensure the hit point is within the bounds of the axis (cylinder extends along the axis direction)
    float projectionLength = dot(hitPoint, normalizedAxis);
    if (projectionLength < 0.0f || projectionLength > 1.0)
    {
        return float3(0.0f, 0.0f, 0.0f); // Hit point is outside valid range
    }

    return hitPoint;
}
float3 RayAxisIntersection(RayData rayData, float3 axis, float radius)
{
    float3 rayOrigin = rayData.origin;
    float3 rayDir = rayData.direction;
    // Ensure the axis is normalized
    float3 normalizedAxis = normalize(axis);

    radius = radius * length(rayData.origin);
     

    // Project ray origin onto the plane perpendicular to the axis
    float3 w = rayOrigin - dot(rayOrigin, normalizedAxis) * normalizedAxis;
    float3 u = rayDir - dot(rayDir, normalizedAxis) * normalizedAxis;

    float a = dot(u, u);
    float b = 2.0f * dot(u, w);
    float c = dot(w, w) - radius * radius;

    // Solve the quadratic equation: at^2 + bt + c = 0
    float discriminant = b * b - 4.0f * a * c;
    if (discriminant < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // No intersection
    }

    float sqrtDiscriminant = sqrt(discriminant);
    float t1 = (-b - sqrtDiscriminant) / (2.0f * a);
    float t2 = (-b + sqrtDiscriminant) / (2.0f * a);

    // Find the closest positive t value
    float tHit = (t1 >= 0.0f) ? t1 : ((t2 >= 0.0f) ? t2 : -1.0f);
    if (tHit < 0.0f)
    {
        return float3(0.0f, 0.0f, 0.0f); // No valid intersection
    }
    // Calculate the hit point using the ray equation: hitPoint = rayOrigin + tHit * rayDir
    float3 hitPoint = rayOrigin + t1 * rayDir;
    // Ensure the hit point is within the bounds of the axis (cylinder extends along the axis direction)
    float projectionLength = dot(hitPoint, normalizedAxis);
    if (projectionLength < 0.0f || projectionLength > 1.0)
    {
        return float3(0.0f, 0.0f, 0.0f); // Hit point is outside valid range
    }

    return hitPoint;
}



float4 RayAxisColor(RayData rayData)
{
    float radius = 1.0 / pow(2.0, 7);
    float farMultiplier = 0.4;

    float3 originHitPoint = RaySphereIntersection(rayData, float3(0, 0, 0), radius * 1.5);
    if(length(originHitPoint) != 0)
        return float4(0.35 + 0.65 * dot(rayData.direction, normalize(originHitPoint)) * float3(1.0, 1.0, 1.0), 1.0);
    
    float3 xAxis = RayAxisIntersection(rayData, float3(1.0, 0, 0), radius);
    if(length(xAxis) != 0)
        return float4(1.0, 0, 0, 1.0);
    else if(length(RayAxisIntersectionFar(rayData, float3(1.0, 0, 0), radius)) != 0)
        return float4(farMultiplier, 0, 0, 1.0);
    float3 yAxis = RayAxisIntersection(rayData, float3(0, 1.0, 0), radius);
    if(length(yAxis) != 0)
        return float4(0, 1.0, 0, 1.0);
    else if(length(RayAxisIntersectionFar(rayData, float3(0, 1.0, 0), radius)) != 0)
        return float4(0, farMultiplier, 0, 1.0);
    float3 zAxis = RayAxisIntersection(rayData, float3(0, 0, 1.0), radius);
    if(length(zAxis) != 0)
        return float4(0, 0, 1.0, 1.0);
    else if(length(RayAxisIntersectionFar(rayData, float3(0, 0, 1.0), radius)) != 0)
        return float4(0, 0, farMultiplier, 1.0);
    return float4(0, 0, 0, 0);
}
float4 GetColorFromFace(RayData rayData, bool useFront)
{
    float3 hitPoint = RayCellIntersection(rayData, boundsMin, boundsMax, useFront);
       
    if(length(hitPoint) == 0)
        return float4(0, 0, 0, 0);
    
    float3 face = float3(0, 0, 0);
    if(abs(abs(hitPoint.x) - boundsMax.x) < 0.01)
        face.x = boundsMax.x;
    else if(abs(abs(hitPoint.y) - boundsMax.y) < 0.01)
        face.y = boundsMax.y;
    else if(abs(abs(hitPoint.z) - boundsMax.z) < 0.01)
        face.z = boundsMax.z;
    else
        face = hitPoint;
    float boundsShade = 0.5 + 0.5 * dot(normalize(sunDirection), normalize(face));
    float4 faceColor = sphereColor;
    if(useFront)
        faceColor = backgroundColor;
    return float4(faceColor.xyz * boundsShade, 1.0);
}
float4 GetBoundsColor(RayData rayData)
{
    //float3 hitMin = RayCellIntersection(rayData, boundsMin, boundsMax, true);
    float4 colMin = GetColorFromFace(rayData, true);
    float4 colMax = GetColorFromFace(rayData, false);

    if(length(colMin) == 0 && length(colMax) == 0)
        return float4(0, 0, 0, 0);

    float frontTransparency = 0.4;
    return float4(colMin.xyz * frontTransparency, 1.0) + float4(colMax.xyz * (1.0 - frontTransparency), 1.0);
}
float4 GetCellColor(RayData rayData, int cellIndex)
{
    float3 hitMin = RayCellIntersection(rayData, cellIndex);
    if(length(hitMin) == 0)
        return float4(0, 0, 0, 0);
    float3 cellMidPoint = float3(GetCellFromIndex(cellIndex)) + gridSize;
    float cellShade = 0.5 - 0.5 * dot(normalize(sunDirection), normalize(hitMin));
    
    return float4(cellBaseColor.xyz * cellShade, 1.0);
}

float3 CellToPosition(int3 cell)
{
    float3 relativePositionFromOrigin = float3(cell) * gridSize;
    float3 absolutePosition = relativePositionFromOrigin + boundsMin;
    return absolutePosition;
}

int3 CellFromIndex(int cellIndex)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    int cellZ = cellIndex / (cellCount.x * cellCount.y);

    int remainingIndex = cellIndex - cellZ * cellCount.x * cellCount.y;

    int cellY = remainingIndex / cellCount.x;

    int cellX = remainingIndex - cellY * cellCount.x;

    return int3(cellX, cellY, cellZ);
}

float4 GetColorFromClosestObject(RayData rayData)
{
    float minDist = 1e6;
    float4 minColor = float4(0, 0, 0, 0);

    RayData cellRayData;
    cellRayData.origin = rayCellOrigin;
    cellRayData.direction = rayCellDirection;

    int3 testCellFromIndex = CellFromIndex(testCellIndex);
    float3 testCellIndexHitPoint = RayCellIntersection(rayData, CellToPosition(testCellFromIndex), CellToPosition(testCellFromIndex) + gridSize, true);
    if(length(testCellIndexHitPoint) != 0)
    {
        float dist = distance(testCellIndexHitPoint, rayData.origin);
        if(dist < minDist)
        {
            minDist = dist;
            minColor = float4(1.0, 1.0, 1.0, 1.0);
        }
    } 

    float3 testCellHitPoint = RayCellIntersection(rayData, CellToPosition(testCell), CellToPosition(testCell) + gridSize, true);
    if(length(testCellHitPoint) != 0)
    {
        float dist = distance(testCellHitPoint, rayData.origin);
        if(dist < minDist)
        {
            minDist = dist;
            minColor = float4(0, 0, 0, 1.0);
        }
        
    } 
    
    RayData boundsRay;
    int3 cell = FindCell(cellRayData, boundsRay);
    testOffsetBuffer[0] = floor(boundsRay.origin);
    testOffsetBuffer[1] = boundsRay.origin;
    testOffsetBuffer[2] = boundsRay.origin - round(boundsRay.origin);

    if(showAllCells == 0)
    {
        float3 cellHitPoint = RayCellIntersection(rayData, CellToPosition(cell), CellToPosition(cell) + gridSize, true);
        if(length(cellHitPoint) != 0)
        {
            float dist = distance(cellHitPoint, rayData.origin);
            if(dist < minDist)
            {
                minDist = dist;
                minColor = float4(1.0, 0, 0, 1.0);
            }

        } 
    }    
    else
    {
        int2 rayCellData = int2(0, 0);
        int3 closestCell = FindClosestCell(cellRayData, rayData, rayCellData);
        float3 closestCellHitPoint = RayCellIntersection(rayData, CellToPosition(closestCell), CellToPosition(closestCell) + gridSize, true);
        float3 farthestHitPoint = RayCellIntersection(rayData, CellToPosition(closestCell), CellToPosition(closestCell) + gridSize, false);
        if(length(closestCellHitPoint) != 0)
        {
            float dist = distance(closestCellHitPoint, rayData.origin);
            if(dist < minDist)
            {
                minDist = dist;
                minColor = float4(1.0, (float)rayCellData.x / (float)rayCellData.y, 0, 1.0);

                /*float3 farHitPointAdjusted = WorldToGrid(farthestHitPoint);
                float3 delta = farHitPointAdjusted - round(farHitPointAdjusted);

                float edgeSize = 0.02;
                int faceCount = 0;
                if(abs(delta.x) < edgeSize) 
                    faceCount++;
                if(abs(delta.y) < edgeSize)
                    faceCount++;
                if(abs(delta.z) < edgeSize)
                    faceCount++;

                if(faceCount > 1)
                {
                    minColor = float4(0,0,0,1.0);
                    
                }    
                minDist = distance(farthestHitPoint, rayData.origin);*/
            }

        } 
    } 
    /*float3 planeHitPoint = RayPlaneIntersection(rayData, float3(1.0 * testCellIndex, 0, 0), normalize(float3(1.0, 1.0, 1.0)));
    if(length(planeHitPoint) != 0)
    {
        if(length(planeHitPoint < 3))
        {
            float dist = distance(planeHitPoint, rayData.origin);
            if(dist < minDist)
            {
                minDist = dist;
                minColor = float4(0, 0.4, 0, 1.0);
            }
        }
    }*/
        

    float3 lineSegmentHitPoint = RayLineSegmentIntersection(rayData, GridToWorld(boundsRay.origin), GridToWorld(boundsRay.origin + boundsRay.direction), 1.0 / 320.0 / 2.0);
    if(length(lineSegmentHitPoint) != 0)
    {
        float dist = distance(lineSegmentHitPoint, rayData.origin);
        if(dist < minDist)
        {
            minDist = dist;
            minColor = float4(0, 1.0, 1.0, 1.0);
        }
        
    } 
    return minColor;
}

RayData GetBoundsRay(RayData rayData)
{
    RayData tempBoundsRayData;
    tempBoundsRayData.origin = WorldToGrid(rayData.origin);
    tempBoundsRayData.direction = rayData.direction;
    float3 firstHit = RayCellIntersection(tempBoundsRayData, WorldToGrid(boundsMin), WorldToGrid(boundsMax), true) + 0.01;
    float3 lastHit = RayCellIntersection(tempBoundsRayData, WorldToGrid(boundsMin), WorldToGrid(boundsMax), false) + 0.01;

    tempBoundsRayData.origin = firstHit;
    tempBoundsRayData.direction = rayData.direction * distance(firstHit, lastHit);
    return tempBoundsRayData;
}
float3 GetClosestGridHitPoint(RayData rayData, float3 axis)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    float minDist = 1e6;
    float3 closestHitPoint = float3(0, 0, 0);
    for(int i = 0; i < cellCount.x; i++)
    {
        float3 hitPoint = RayPlaneIntersection(rayData, axis * (float)i, axis);
        if(length(hitPoint) == 0)
            continue;
        float3 hitPointRounded = round(hitPoint);
        float3 deltaHitPoint = hitPointRounded - hitPoint;
        //
        if((hitPoint.x + gridWireFrameSize >= 0 && hitPoint.y + gridWireFrameSize >= 0 && hitPoint.z + gridWireFrameSize >= 0) && (hitPoint.x <= cellCount.x && hitPoint.y <= cellCount.y && hitPoint.z <= cellCount.z))
        {
            int moduloCount = 0;
            if(abs(deltaHitPoint.x) < gridWireFrameSize)
                moduloCount++;
            if(abs(deltaHitPoint.y) < gridWireFrameSize)
                moduloCount++;
            if(abs(deltaHitPoint.z) < gridWireFrameSize)
                moduloCount++;
            if(moduloCount > 1)
            {
                float dist = distance(hitPoint, rayData.origin);
                if(dist < minDist)
                {
                    minDist = dist;
                    closestHitPoint = hitPoint;
                }
            }   
            
            
        }    
    }
    return closestHitPoint;
}

float3 GetGridHitPoint(RayData rayData)
{
    float3 closestHitPoint = float3(0, 0, 0);
    float minDist = 1e6;
    float3 xHitPoint = GetClosestGridHitPoint(rayData, float3(1.0, 0, 0));
    float3 yHitPoint = GetClosestGridHitPoint(rayData, float3(0, 1.0, 0));
    float3 zHitPoint = GetClosestGridHitPoint(rayData, float3(0, 0, 1.0));

    if(length(xHitPoint) != 0)
    {
        closestHitPoint = xHitPoint;
        minDist = distance(xHitPoint, rayData.origin);
    }    
    if(length(yHitPoint) != 0 && distance(rayData.origin, yHitPoint) < minDist)
    {
        closestHitPoint = yHitPoint;
        minDist = distance(yHitPoint, rayData.origin);
    }
    if(length(zHitPoint) != 0 && distance(rayData.origin, zHitPoint) < minDist)
    {
        closestHitPoint = zHitPoint;
        minDist = distance(zHitPoint, rayData.origin);
    }
    return closestHitPoint;
}
float3 GetPlaneHitPoint3(RayData rayData)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    float3 minHitPoint = float3(0, 0, 0);
    float minDist = 1e6;
    for(int i = 0; i <= cellCount.x * 2; i++)
    {
        float3 planeHitPoint = RayPlaneIntersection(rayData, float3((float)(i), 0, 0), normalize(float3(1.0, 1.0, 1.0)));
        if(length(planeHitPoint) != 0)
        {
            if((planeHitPoint.x > 0 && planeHitPoint.y > 0 && planeHitPoint.z > 0) && ((planeHitPoint.x < (float)cellCount.x) && (planeHitPoint.y < (float)cellCount.y) && (planeHitPoint.z < (float)cellCount.z)))
            {
                float dist = distance(rayData.origin, planeHitPoint);
                if(dist < minDist)
                {
                    minDist = dist;
                    minHitPoint = planeHitPoint;
                }
            }
        }
    }
    return minHitPoint;
}
float3 GetPlaneHitPoint2(RayData rayData)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    float3 minHitPoint = float3(0, 0, 0);
    float minDist = 1e6;
    for(int i = 0; i <= cellCount.x * 2; i++)
    {
        float3 planeHitPoint = RayPlaneIntersection(rayData, float3((float)(cellCount.x - i), 0, 0), normalize(float3(-1.0, 1.0, 1.0)));
        if(length(planeHitPoint) != 0)
        {
            if((planeHitPoint.x > 0 && planeHitPoint.y > 0 && planeHitPoint.z > 0) && ((planeHitPoint.x < (float)cellCount.x) && (planeHitPoint.y < (float)cellCount.y) && (planeHitPoint.z < (float)cellCount.z)))
            {
                float dist = distance(rayData.origin, planeHitPoint);
                if(dist < minDist)
                {
                    minDist = dist;
                    minHitPoint = planeHitPoint;
                }
            }
        }
    }
    return minHitPoint;
}
float3 GetPlaneHitPoint(RayData rayData, float3 axis)
{
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);

    float3 minHitPoint = float3(0, 0, 0);
    float minDist = 1e6;
    for(int i = 0; i <= cellCount.x * 2; i++)
    {
        float3 planeHitPoint = RayPlaneIntersection(rayData, axis * i, normalize(float3(1.0, 0, 0) + axis));
        if(length(planeHitPoint) != 0)
        {
            if((planeHitPoint.x > 0 && planeHitPoint.y > 0 && planeHitPoint.z > 0) && ((planeHitPoint.x < (float)cellCount.x) && (planeHitPoint.y < (float)cellCount.y) && (planeHitPoint.z < (float)cellCount.z)))
            {
                float dist = distance(rayData.origin, planeHitPoint);
                if(dist < minDist)
                {
                    minDist = dist;
                    minHitPoint = planeHitPoint;
                }
            }
        }
    }
    return minHitPoint;
}
float4 RenderGrid(RayData rayData)
{
    RayData boundsRay = GetBoundsRay(rayData);
    if(length(boundsRay.origin) == 0)
        return backgroundColor;
    RayData newRayData;
    newRayData.origin = WorldToGrid(rayData.origin);//rayData.origin;
    newRayData.direction = rayData.direction;

    //int3 intersectionCount = int3(ceil(boundsRay.direction));
    float3 closestGridHitPoint = GetGridHitPoint(newRayData);
    float3 closestPlaneHitPointY = float3(0, 0, 0);//GetPlaneHitPoint(newRayData, float3(0, 1.0, 0));
    float3 closestPlaneHitPointZ = float3(0, 0, 0);//GetPlaneHitPoint(newRayData, float3(0, 0, 1.0));

    float gridDist = distance(newRayData.origin, closestGridHitPoint);
    float planeDistY = distance(newRayData.origin, closestPlaneHitPointY);
    float planeDistZ = distance(newRayData.origin, closestPlaneHitPointZ);

    if(length(closestGridHitPoint) == 0)
        gridDist = 1e6;
    if(length(closestPlaneHitPointY) == 0)
        planeDistY = 1e6;
    if(length(closestPlaneHitPointZ) == 0)
        planeDistZ = 1e6;
    float3 boundsSize = boundsMax - boundsMin;
    int3 cellCount = ceil(boundsSize / gridSize);
    if(length(closestGridHitPoint) != 0 && gridDist < planeDistY && gridDist < planeDistZ)
    {
        
        int moduloCount = 0;
        if(closestGridHitPoint.x < gridWireFrameSize || abs(closestGridHitPoint.x - (float)(cellCount.x)) < gridWireFrameSize)
            moduloCount++;
        if(closestGridHitPoint.y < gridWireFrameSize || abs(closestGridHitPoint.y - (float)(cellCount.y)) < gridWireFrameSize)
            moduloCount++;
        if(closestGridHitPoint.z < gridWireFrameSize || abs(closestGridHitPoint.z - (float)(cellCount.z)) < gridWireFrameSize)
            moduloCount++;

        if(moduloCount > 1)
            return float4(1.0, 1.0, 0, 1.0);

        return float4(0, 0, 0, 1.0);
    }    
    if(length(closestPlaneHitPointY) != 0 && planeDistY < gridDist && planeDistY < planeDistZ)
    {
        if(abs(closestPlaneHitPointY.x) < gridWireFrameSize || abs(closestPlaneHitPointY.y) < gridWireFrameSize || abs(closestPlaneHitPointY.z) < gridWireFrameSize)
            return float4(0, 1.0, 1.0, 1.0);
        return float4(0, 0.25 * (1.0 - distance((float3(0, 0, 0)), closestPlaneHitPointY) / (float)cellCount.x), 0, 1.0);
    }
    if(length(closestPlaneHitPointZ) != 0 && planeDistZ < gridDist && planeDistZ < planeDistY)
    {
        if(abs(closestPlaneHitPointZ.x) < gridWireFrameSize || abs(closestPlaneHitPointZ.y) < gridWireFrameSize || abs(closestPlaneHitPointZ.z) < gridWireFrameSize)
            return float4(1.0, 1.0, 0, 1.0);
        return float4(0, 0, 0.25 * (1.0 - distance((float3(0, 0, 0)), closestPlaneHitPointZ) / (float)cellCount.x), 1.0);
    }
    float4 minColor = backgroundColor;


    return float4(0, 0, 0, 0);
}

// Computes the color for a given pixel
float4 GetPixelColor(uint2 pixel)
{
    RayData rayData = PixelToRay(pixel);
    float4 rayAxisColor = RayAxisColor(rayData);
    if(length(rayAxisColor) != 0)
        return rayAxisColor;
    if(onlyShowGrid == 1)
    {
        float4 gridColor = RenderGrid(rayData);
        if(length(gridColor) != 0)
            return gridColor;
    }
         

    

    float4 intersectionColor = GetColorFromClosestObject(rayData);
    if(length(intersectionColor) != 0)
        return intersectionColor;
    

    
    float4 boundsColor = GetBoundsColor(rayData);
    if(length(boundsColor) != 0)
        return boundsColor;

    return backgroundColor;
}

[numthreads(8, 8, 1)]
void CellRenderer (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= resolution.x || id.y >= resolution.y)
        return;

    float4 color = GetPixelColor(id.xy);
    Result[id.xy] = color;
}
